# Сложить два числа

В этом задании необходимо сложить два числа. Функция в качестве аргументов может принимать как положительное или отрицательное число, так и строку, в которой содержится число
(например, "12").
Если переданная строка содержит не только цифры, то функция должна вернуть NaN. Например, нельзя сложить строку "12 бегемотов" и строку "38 попугаев".
Подсказка
Для решения задачи рекомендуем познакомиться с исключениями, а также методами parseInt, NaN и Number.

# Проверка времени на корректность

В этом задании необходимо проверить, что числа составляют корректное время. 
+ Гарантируется, что в функцию передаются два целых числа.
+ Часы мы считаем правильными, если они находятся в диапазоне [0, 23].
+ Минуты мы считаем правильными, если они находятся в диапазоне [0, 59]. Если часы и минуты правильные, то возвращаем 'true', иначе — 'false'.

# Добавление интервала ко времени

В этом задании необходимо реализовать функцию, которая увеличивает время на заданное количество минут.
На вход функция принимает 3 параметра: часы, минуты, интервал в минутах, на который нужно изменить время.
+ Гарантируется, что любой из 3 параметров целое положительное число.
+ Параметр часы принимает значение в диапазоне [0, 23].
+ Параметр минуты принимает значение в диапазоне [0, 59].
+ Прибавляемый интервал может быть больше 60 минут.
+ Переход в следующие сутки должен корректно обрабатываться.
+ Функция должна возвращать корректно отформатированное время: 1:2 –> 01:02
## Подсказки
+ Для выполнения этого задания могут понадобиться методы глобального объекта Math. Например, метод floor.
+ При реализации рекомендуем внимательно проверить все краевые случаи: именно там допускается большинство ошибок.

# Список хештегов

В этом задании необходимо вернуть список хештегов, которые содержатся в твите. Строка содержит только буквы русского и латинского алфавита, знак решетки и пробелы.
+ Гарантируется, что в функцию передается непустая строка.
+ Слова в строке разделены одним пробелом.
+ Хештег начинается со знака решетки (#) и состоит из одного слова.
+ В результирующем массиве хештеги должны быть без решетки.
+ Если в слове хештегов нет, то возвращается пустой массив.
## Подсказка
Для выполнения этого задания может понадобиться метод строки split.

# Уникальный список хештегов

В этом задании необходимо убрать повторения из списка хештегов и привести их к нижнему регистру. Результатом должна быть строка. 
Хештеги в строке должны быть разделены запятой и пробелом: `tag1, tag2, tag3`.
+ Гарантируется, что массив содержит только хештеги.
+ Массив может быть пустым. В этом случае должна вернуться пустая строка.
+ Хештег — непустая строка, состоящая из одного слова.
+ Повторяющиеся хештеги нужно игнорировать.
+ При сравнении хештегов следует игнорировать регистр букв.
+ Порядок хештегов из исходного массива должен сохраниться.
## Подсказка
Для выполнения этого задания может понадобиться метод массива join.

# Телефонная книга

В этом задании необходимо реализовать функцию, через которую можно управлять телефонной книгой.
Для управления телефонной книгой нужно реализовать три команды:
+ ADD — добавляет контакт
+ REMOVE_PHONE — удаляет номер
+ SHOW — возвращает содержимое телефонной книги
Гарантируется, что функция будет вызываться корректно, только со списком перечисленных команд. Корректность входных данных проверять не нужно.
Имя команды пишется большими буквами, параметры разделяются одним пробелом.
Гарантируется уникальность добавляемых телефонов.
## Команда ADD
Добавляет контакт в телефонную книгу со списком телефонов. Телефоны перечисляются через запятую. 
Если такой контакт существует, то команда пополняет список телефонов контакта.

## Команда REMOVE_PHONE
Удаляет телефон из телефонной книги. Если телефон успешно удалён, то функция должна вернуть true. 
Если такого телефона в телефонной книге не существует, то возвращается false.

## Команда SHOW
Возвращает массив контактов с их телефонами. Массив содержит строчки вида: "Имя: Телефон1, Телефон2". 
Массив должен быть отсортирован по имени контакта. Телефоны идут в порядке добавления их в телефонную книгу. Контакт с пустым списком телефонов не должен возвращаться.

## Подсказка
В этой задаче удобно разбить операции над телефонной книгой на отдельные функции. Их следует вызывать для конкретной операции. 
При использовании такой декомпозиции важно не забыть вернуть результат выполнения функции. Иначе основная функция будет возвращать undefined.

# Управление временем

В этом задании необходимо реализовать дополнительные функции для управления временем.
В функцию всегда передается строка в правильном и полном формате. Дополнительных проверок не требуется.
Формат даты — "YYYY‒MM‒DD HH:SS", где YYYY — год, MM — месяц, DD — день, HH — час, SS — минуты
## В функции add/subtract всегда передается целое число
Гарантируется, что после всех манипуляций получится корректная дата, которая будет не ранее 1 января 2000 года
## Функции add/subtract
Каждая функция принимает первым аргументом количество единиц, на которое нужно изменить дату, а вторым — единицу измерения.

Можно менять следующие значения: years (годы), months (месяцы), days (дни), hours (часы), minutes (минуты)

## Обработка ошибок
Если первый аргумент отрицательный, либо второй содержит неизвестную единицу измерения, функции должны выбросить исключение TypeError.

## Подсказки
Решение задания не требует использования регулярных выражений, но с ними реализация может быть лаконичнее.

### Даты
В реализации советуем использовать объект Date. В нём реализован правильный переход через месяц, год, час.
Обратите внимание, что нумерация месяцев идет с "0"

### Регулярные выражения
При использовании регулярных выражений полезно прочитать документацию. Обратите внимание на символьный класc "\d", сопоставляемый с числом и на кванитификаторы "{}", через которые удобно указать точное количество символов
Для разбора строки, может пригодиться строковый метод match.

### Реализация интерфейса
Для реализации рекомендуемого интерфейса необходимо из функции date вернуть объект с методами. Чтобы эти методы можно было вызывать цепочкой, из каждого метода нужно возвращать сам объект.

# Выборка элементов коллекции

В этом задании необходимо написать библиотеку, которая упростит работу с коллекцией однотипных объектов.

Для управления коллекцией нужно реализовать три функции:

+ query — функция, выполняющая запрос с заданными операциями;
+ select— операция выбора необходимых полей объектов;
+ filterIn— операция фильтрации объектов коллекции.

+ После выполнения функции 'query' не должна измениться исходная коллекция.
+ Если в функцию 'query' передать только коллекцию, то вернётся её копия.
+ Операция 'select' должна игнорировать несуществующие в объекте поля.
+ Несколько операций 'select' должны отработать как одна с пересечёнными аргументами. Например, если мы выбираем поля a и b, а затем b и c, то в результате должно выбраться только поле b.
+ Несколько операций 'filterIn' должны отработать как одна с пересечёнными аргументами. Например, если фильтруем поле по значениям a и b, а затем по b и c, то в результате отфильтроваться должно только по значени b.
+ Операции должны выполняться в определённом порядке. В первую очередь происходит фильтрация, а затем выборка полей. Таким образом, можно фильтровать коллекцию даже по тем полям, которые не указаны в функции select.
+ Порядок элементов после выполнения операций должен сохраниться.
+ Гарантируется, что функция 'query' будет вызываться корректно. Дополнительную проверку аргументов делать не нужно.
+ Предполагается, что поля объектов имеют значения типа String или Number.
## Функция 'query'
Выполняет запрос к коллекции. Принимает коллекцию и операции. Возвращает коллекцию после применения всех операций. 
В качестве операций может быть использован 'filterIn', 'select'.

```
lib.query(collection, operation1, operation2, ...);
```

## Операция 'select'
Позволяет выбрать определённые поля объектов коллекции. Принимает список полей.
```
lib.select('fieldName1', 'fieldName2', ...);
```

## Операция 'filterIn'
Позволяет отфильтровать коллекцию. Принимает название поля и допустимые значения. 
После выполнения фильтрации должны остаться объекты, у которых поле имеет одно из допустимых значений.
```
lib.filterIn('fieldName', ['acceptedValue1', 'acceptedValue2', ...]);
```

## Подсказка
К решению данной задачи есть два подхода:

+ Из функций select и filterIn можно возвращать названия операций с параметрами. И позже ориентироваться на них при выполнении функции query.

```
function select () {
    // var fields = ...
    
    return ['select', fields];
}
```
+ Из функции можно возвращать функции, в которые позже будет передана коллекция. 
Для определения порядка понадобится возвращать именнованные функции, чтобы позже по именам определить порядок выполнения.
```
function select () {
    // var fields = ...
    
    return function select(collection) {
        // ...
        
        return collection;
    }
}
```

# Подписка на события

В этом задании необходимо реализовать библиотеку, позволяющую подписываться на события и получать по ним уведомления.

В библиотеке нужно реализовать три метода:

+ on — подписка на событие;
+ off — отписка от события;
+ emit — оповещение всех подписчиков.

Все функции будут вызываться корректно, дополнительных проверок не требуется.
Все функции должны возвращать объект, от которого вызваны (emitter), чтобы их можно было вызывать в цепочке (chaining):
```
emitter
  .on(...)
  .off(...)
  .emit(...)
  .on(...);
```
## Метод 'on'
Подписывает на событие. На любое событие подписчик может подписаться неограниченное количество раз.
```
emitter.on(eventName, subscriber, handler);
```
+ eventName — название события, на которое подписываемся.
+ subscriber — объект-подписчик.
+ handler — функция-обработчик.
## Метод 'off'
Отписывает от события подписчика. После отписки, при возникновении данного события, никаких обработчиков, связанных с этим подписчиком, не должно быть вызвано. 
Есть возможность повторно подписаться и снова получать события.
```
emitter.off(eventName, subscriber);
```
+ eventName — название события, от которого отписываемся.
+ subscriber — объект-подписчик.
## Метод 'emit'
Оповещение всех подписчиков (не отписавшихся). Вызывает все функции-обработчики в порядке подписки.
```
emitter.emit(eventName);
```
+ eventName — название события, о котором оповещаем подписчиков.
